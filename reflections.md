# Reflections

- Game object state management can get complex quickly. Something that would suit my game design style is an interface `IState` with method declarations like `on_state_entered()`, `on_state_exited()`, `process_state()`. This would have made my enemy design way cleaner, more readable, more extendable with future states. Need to spend some time thinking about how this would work with timers, since state transitions can be dependent on timeouts. Also need to research more about extending state and behavior when inheriting from abstract node types (e.g. how to properly recycle states/behaviors when having multiple enemy types inheriting from the generic `Enemy`)
- Game states (title screen, playing, game over) were a pain to implement, touching almost every scene in this project. Probably because I only have 1 root scene that I wanted to display all game objects in for all states--the world scene is instantiated once and never freed, so that the player can roam around in the title screen, and the enemies stay on screen after player death. In future games with this feature, implement game states before anything else. Otherwise use a more traditional game start style where the world scene is instantiated at game start and freed at game over.